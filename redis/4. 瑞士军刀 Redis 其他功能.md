# 瑞士军刀 Redis 其他功能

## 慢查询

![生命周期](assets/4-1.png)

- 慢查询发生在第3阶段
- 客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素

**slowlog-max-len**

1. 先进先出队列
2. 固定长度
3. 保存在内存内

**slowlog-log-slower-than**

1. 慢查询阀值(单位 微秒)
2. slowlog-log-slower-than = 0 记录所有命令
3. slowlog-log-slower-than < 0 不记录任何命令

**默认值**

```text
config get slowlog-max-len = 128
config get slowlog-log-slower-than = 10000
```

**动态配置**

```text
config set slowlog-max-len = 1000
```

**慢查询命令**

```shell
# 获取慢查询队列
slowlog get [n]
# 获取慢查询队列长度
slowlog len
# 清空慢查询队列
slowlog reset
```

**运维经验**

1. slowlog-log-slower-than不要设置过大，默认10ms，通常设置1ms。
2. slowlog-max-len不要设置过小，通常设置1000左右。
3. 理解命令生命周期。
4. 定期持久化慢查询。

## pipeline

![流水线](assets/4-2.png)

1次pipeline(n条命令) = 1次网络时间 + n次命令时间

1. Redis的命令时间是微秒级别。
2. pipeline每次条数要控制(网络)。

```java
Jedis jedis = new Jedis("127.0.0.1", 6379);
Pipeline pipeline = jedis.pipelined();
for (int i = 0; i < 100; i ++) {
    pipeline.hset("hashkey:" + i, "field" + i, "value" + i);
}
pipeline.syncAndReturnAll();
```

M操作是原子的，pipeline是非原子的。

**使用建议**

1. 注意每次pipeline携带数据量。
2. pipeline每次只能作用在一个Redis节点上。
3. M操作和pipeline的区别。