# 深入 Redis Cluster

## 集群伸缩原理

集群伸缩就是槽和数据在节点之间的移动。

![集群伸缩](assets/10-1.png)

![集群伸缩](assets/10-2.png)

## 扩容集群

### 准备新节点

- 集群模式
- 配置和其他节点统一
- 启动后是孤儿节点

![准备新节点](assets/10-3.png)

### 加入集群

**作用**

- 为它迁移槽和数据实现扩容
- 作为从节点负责故障转移

![加入集群](assets/10-4.png)

### 迁移槽和数据

**槽迁移计划**

![槽迁移计划](assets/10-5.png)

**迁移数据**

![迁移数据](assets/10-6.png)

## 客户端路由

### moved重定向

![重定向](assets/10-7.png)

### ask重定向

![重定向](assets/10-8.png)

- moved表示槽已经确定迁移
- ask表示槽还在迁移中

### smart客户端

**原理**

1. 从集群中选一个可运行节点，使用cluster slots初始化槽和节点映射。
2. 将cluster slots的结果映射到本地，为每个节点创建JedisPool。
3. 准备执行命令。

**执行命令**

![客户端](assets/10-9.png)

## JedisCluster

```java
Set<HostAndPort> nodeList = new HashSet<HostAndPort>();
nodeList.add(new HostAndPort(HOST1, PORT1));
nodeList.add(new HostAndPort(HOST2, PORT2));
nodeList.add(new HostAndPort(HOST3, PORT3));
nodeList.add(new HostAndPort(HOST4, PORT4));
nodeList.add(new HostAndPort(HOST5, PORT5));
nodeList.add(new HostAndPort(HOST6, PORT6));
JedisCluster jedisCluster = new JedisCluster(nodeList, timeout, poolConfig);
jedisCluster.set(key, value);
jedisCluster.get(key);
```

**使用技巧**

1. 单例：内置了所有节点的连接池
2. 无需手动借还连接池
3. 合理设置commons-pool

## 批量操作怎么实现

- mget、mset必须在一个槽

客户端对key进行分组，分别批量执行。

![批量优化](assets/10-10.png)

## 故障转移

### 故障发现

- 通过ping/pong消息实现故障发现：不需要sentinel

**主观下线**

某个节点认为另一个节点不可用。

![主观下线](assets/10-11.png)

**客观下线**

当半数以上持有槽的主节点都标记某节点主观下线。

![客观下线](assets/10-12.png)

**尝试客观下线**

- 通知集群内所有节点标记故障节点为客观下线
- 通知故障节点的从节点触发故障转移流程

![尝试客观下线](assets/10-13.png)

### 故障恢复

**资格检查**

- 每个从节点检查与故障主节点的断线时间。
- 超过cluster-node-timeout * cluster-slave-validity-factor取消资格。
- cluster-slave-validity-factor默认是10。

**准备选举时间**

![准备选举时间](assets/10-14.png)

**选举投票**

![选举投票](assets/10-15.png)

**替换主节点**

1. 当前从节点取消复制成为主节点。
2. 执行clusterDelSlot撤销故障主节点分配的槽，并执行clusterAddSlot把这些槽分配给自己。
3. 向集群广播自己的pong消息，表明已经替换了故障从节点。